import time
import logging
import requests  # Para realizar peticiones HTTP
from blockchain import Blockchain, Block

BLOCK_TIME = 10  # Tiempo de bloque en segundos
BLOCK_REWARD = 50  # Recompensa por bloque
COMMISION_RATE = 0.01  # Tasa de comisión por transacción
BLOCKCHAIN_API_URL = "http://2.137.118.154:5000/api"  # IP pública y puerto

class Miner:
    def __init__(self, blockchain: Blockchain, leader: int = 0):
        self.blockchain = blockchain
        self.leader = leader  # Para el minero líder (si es un nodo que mina)

    def mine_block(self):
        """
        Mina un nuevo bloque, incluso si no hay transacciones pendientes.
        Se minará un bloque vacío si no hay transacciones.
        """
        if self.leader == 0:  # Solo los mineros pueden minar
            # Si hay transacciones pendientes, se usarán, si no, el bloque será vacío
            block = Block(
                len(self.blockchain.chain),  # Índice del bloque
                self.blockchain.pending_transactions,  # Transacciones pendientes (pueden ser vacías)
                time.time(),  # Timestamp
                self.blockchain.chain[-1].hash if self.blockchain.chain else None  # Hash del bloque anterior
            )

            if self.blockchain.add_block(block):  # Si el bloque es validado y añadido
                logging.info(f"Nuevo bloque minado: {block.hash}")
                self.blockchain.pending_transactions = []  # Limpiar las transacciones pendientes
                self.reward_miner()  # Recompensar al minero

                # Enviar el bloque minado a la blockchain a través de la IP pública
                self.send_block_to_blockchain(block)
    
    def reward_miner(self):
        """
        Recompensar al minero con una transacción de recompensa.
        """
        reward_transaction = Transaction(
            from_address="system",
            to_address="miner_address",  # Reemplazar con la dirección del minero
            amount=BLOCK_REWARD,
            signature=None,  # Asumimos que no tiene firma, ya que es una transacción del sistema
            zk_proof=None  # Sin prueba de conocimiento cero
        )

        # Añadir la transacción de recompensa a las transacciones pendientes
        self.blockchain.pending_transactions.append(reward_transaction)
    
    def send_block_to_blockchain(self, block):
        """
        Envía el bloque minado a la blockchain a través de la IP pública.
        """
        try:
            response = requests.post(f"{BLOCKCHAIN_API_URL}/add_block", json=block.to_dict())  # Asumiendo que tu blockchain tiene un endpoint "add_block"
            if response.status_code == 200:
                logging.info(f"Bloque enviado correctamente a la blockchain: {block.hash}")
            else:
                logging.error(f"Error al enviar el bloque: {response.text}")
        except requests.exceptions.RequestException as e:
            logging.error(f"Error al conectar con la API de la blockchain: {e}")
    
    def mining_loop(self):
        """
        Bucle de minería que mina un bloque cada ciertos segundos.
        """
        while True:
            try:
                self.mine_block()  # Intentar minar un bloque
                time.sleep(BLOCK_TIME)  # Esperar antes de intentar minar el siguiente bloque
            except KeyboardInterru
