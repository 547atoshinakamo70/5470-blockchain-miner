#!/usr/bin/env python3
import hashlib
import json
import time
import threading
import logging
import os
import random
import sys
from ecdsa import SigningKey, SECP256k1
import psycopg2
from psycopg2 import pool
from dotenv import load_dotenv

# Cargar variables de entorno
load_dotenv()

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("blockchain.log"),
        logging.StreamHandler(sys.stdout)
    ]
)

# Parámetros de la blockchain
TOKEN_NAME = "5470"
TOKEN_SYMBOL = "547"
TOKEN_SUPPLY = 5470000  # Total de tokens
BLOCK_TIME = 10  # Tiempo entre bloques
BLOCK_REWARD_INITIAL = 50  # Recompensa inicial por bloque

# Conexión a la base de datos con pool
db_pool = psycopg2.pool.ThreadedConnectionPool(
    minconn=1,
    maxconn=50,
    dbname="blockchain",
    user="postgres",
    password=os.getenv('DB_PASSWORD', 'YOUR_DB_PASSWORD'),
    host="localhost",
    port="5432"
)

# Función para generar claves ECDSA
def generate_key_pair():
    sk = SigningKey.generate(curve=SECP256k1)
    vk = sk.get_verifying_key()
    return sk.to_string().hex(), vk.to_string().hex()

# Clase para representar una transacción
class Transaction:
    def __init__(self, from_address, to_address, amount, timestamp):
        self.from_address = from_address
        self.to_address = to_address
        self.amount = amount
        self.timestamp = timestamp
        self.signature = None

    def sign(self, private_key):
        tx_data = f"{self.from_address}{self.to_address}{self.amount}{self.timestamp}"
        sk = SigningKey.from_string(bytes.fromhex(private_key), curve=SECP256k1)
        self.signature = sk.sign(tx_data.encode()).hex()

    def to_dict(self):
        return {
            "from": self.from_address,
            "to": self.to_address,
            "amount": self.amount,
            "timestamp": self.timestamp,
            "signature": self.signature
        }

# Clase para representar un bloque
class Block:
    def __init__(self, index, transactions, timestamp, previous_hash, nonce=0):
        self.index = index
        self.transactions = transactions
        self.timestamp = timestamp
        self.previous_hash = previous_hash
        self.nonce = nonce
        self.hash = self.calculate_hash()

    def calculate_hash(self):
        block_string = json.dumps({
            "index": self.index,
            "transactions": [t.to_dict() for t in self.transactions],
            "timestamp": self.timestamp,
            "previous_hash": self.previous_hash,
            "nonce": self.nonce
        }, sort_keys=True).encode()
        return hashlib.sha256(block_string).hexdigest()

# Clase para la blockchain
class Blockchain:
    def __init__(self):
        self.chain = self.load_chain_from_db()
        self.pending_transactions = []
        self.balances = self.load_balances_from_db()
        self.owner_private_key, self.owner_public_key = self.create_genesis_block()

    def create_genesis_block(self):
        private_key, public_key = generate_key_pair()
        genesis_tx = Transaction("genesis", public_key, TOKEN_SUPPLY, time.time())
        genesis_block = Block(0, [genesis_tx], time.time(), "0")
        if not self.chain:
            self.chain.append(genesis_block)
            self.balances[public_key] = TOKEN_SUPPLY
            self.save_chain_to_db()
            self.save_balances_to_db()
        return private_key, public_key

    def add_block(self, block):
        if self.validate_block(block):
            self.chain.append(block)
            for tx in block.transactions:
                if tx.from_address == "system":
                    self.balances[tx.to_address] = self.balances.get(tx.to_address, 0) + tx.amount
                elif tx.from_address != "genesis":
                    self.balances[tx.from_address] -= tx.amount
                    self.balances[tx.to_address] = self.balances.get(tx.to_address, 0) + tx.amount
            self.save_chain_to_db()
            self.save_balances_to_db()
            return True
        return False

    def validate_block(self, block):
        for tx in block.transactions:
            if tx.from_address not in ["system", "genesis"]:
                if self.balances.get(tx.from_address, 0) < tx.amount:
                    return False
        return True

    def load_chain_from_db(self):
        conn = db_pool.getconn()
        try:
            with conn.cursor() as cur:
                cur.execute("SELECT data FROM blockchain ORDER BY index")
                chain = [json.loads(row[0]) for row in cur.fetchall()]
                return [Block(b["index"], [Transaction(**t) for t in b["transactions"]],
                              b["timestamp"], b["previous_hash"], b["nonce"]) for b in chain]
        except Exception as e:
            logging.error(f"Error cargando cadena desde DB: {e}")
            return []
        finally:
            db_pool.putconn(conn)

    def save_chain_to_db(self):
        conn = db_pool.getconn()
        try:
            with conn.cursor() as cur:
                for block in self.chain:
                    cur.execute(
                        "INSERT INTO blockchain (index, data) VALUES (%s, %s) ON CONFLICT (index) DO UPDATE SET data = %s",
                        (block.index, json.dumps(block.__dict__), json.dumps(block.__dict__))
                    )
                conn.commit()
        except Exception as e:
            logging.error(f"Error guardando cadena en DB: {e}")
        finally:
            db_pool.putconn(conn)

    def load_balances_from_db(self):
        conn = db_pool.getconn()
        try:
            with conn.cursor() as cur:
                cur.execute("SELECT address, balance FROM balances")
                return {row[0]: row[1] for row in cur.fetchall()}
        except Exception as e:
            logging.error(f"Error cargando saldos desde DB: {e}")
            return {}
        finally:
            db_pool.putconn(conn)

    def save_balances_to_db(self):
        conn = db_pool.getconn()
        try:
            with conn.cursor() as cur:
                for address, balance in self.balances.items():
                    cur.execute(
                        "INSERT INTO balances (address, balance) VALUES (%s, %s) ON CONFLICT (address) DO UPDATE SET balance = %s",
                        (address, balance, balance)
                    )
                conn.commit()
        except Exception as e:
            logging.error(f"Error guardando saldos en DB: {e}")
        finally:
            db_pool.putconn(conn)

# Clase de Consenso para la minería
class Consensus:
    def __init__(self, blockchain):
        self.blockchain = blockchain
        self.leader = random.choice(range(1))  # Solo un nodo mina

    def mine_block(self):
        if self.blockchain.pending_transactions:
            block = Block(len(self.blockchain.chain), self.blockchain.pending_transactions, time.time(), self.blockchain.chain[-1].hash)
            if self.blockchain.add_block(block):
                logging.info(f"Nuevo bloque minado: {block.hash}")
                self.blockchain.pending_transactions = []

# Bucle de minería en segundo plano
def mining_loop():
    while True:
        try:
            consensus.mine_block()
            time.sleep(BLOCK_TIME)
        except Exception as e:
            logging.error(f"Error en minería: {e}")

# Inicialización de la blockchain y consenso
blockchain = Blockchain()
consensus = Consensus(blockchain)

# Iniciar minería en segundo plano
threading.Thread(target=mining_loop, daemon=True).start()

if __name__ == "__main__":
    logging.info("Blockchain operativa. Ejecutando ciclo principal...")
    while True:
        time.sleep(60)
